{"ast":null,"code":"/** @license React v0.15.0\n * scheduler-unstable_mock.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    var enableSchedulerDebugging = false;\n    var currentTime = 0;\n    var scheduledCallback = null;\n    var scheduledTimeout = null;\n    var timeoutTime = -1;\n    var yieldedValues = null;\n    var expectedNumberOfYields = -1;\n    var didStop = false;\n    var isFlushing = false;\n    var needsPaint = false;\n    var shouldYieldForPaint = false;\n\n    function requestHostCallback(callback) {\n      scheduledCallback = callback;\n    }\n\n    function requestHostTimeout(callback, ms) {\n      scheduledTimeout = callback;\n      timeoutTime = currentTime + ms;\n    }\n\n    function cancelHostTimeout() {\n      scheduledTimeout = null;\n      timeoutTime = -1;\n    }\n\n    function shouldYieldToHost() {\n      if (expectedNumberOfYields !== -1 && yieldedValues !== null && yieldedValues.length >= expectedNumberOfYields || shouldYieldForPaint && needsPaint) {\n        // We yielded at least as many values as expected. Stop flushing.\n        didStop = true;\n        return true;\n      }\n\n      return false;\n    }\n\n    function getCurrentTime() {\n      return currentTime;\n    }\n\n    function forceFrameRate() {// No-op\n    } // Should only be used via an assertion helper that inspects the yielded values.\n\n\n    function unstable_flushNumberOfYields(count) {\n      if (isFlushing) {\n        throw new Error('Already flushing work.');\n      }\n\n      if (scheduledCallback !== null) {\n        var cb = scheduledCallback;\n        expectedNumberOfYields = count;\n        isFlushing = true;\n\n        try {\n          var hasMoreWork = true;\n\n          do {\n            hasMoreWork = cb(true, currentTime);\n          } while (hasMoreWork && !didStop);\n\n          if (!hasMoreWork) {\n            scheduledCallback = null;\n          }\n        } finally {\n          expectedNumberOfYields = -1;\n          didStop = false;\n          isFlushing = false;\n        }\n      }\n    }\n\n    function unstable_flushUntilNextPaint() {\n      if (isFlushing) {\n        throw new Error('Already flushing work.');\n      }\n\n      if (scheduledCallback !== null) {\n        var cb = scheduledCallback;\n        shouldYieldForPaint = true;\n        needsPaint = false;\n        isFlushing = true;\n\n        try {\n          var hasMoreWork = true;\n\n          do {\n            hasMoreWork = cb(true, currentTime);\n          } while (hasMoreWork && !didStop);\n\n          if (!hasMoreWork) {\n            scheduledCallback = null;\n          }\n        } finally {\n          shouldYieldForPaint = false;\n          didStop = false;\n          isFlushing = false;\n        }\n      }\n    }\n\n    function unstable_flushExpired() {\n      if (isFlushing) {\n        throw new Error('Already flushing work.');\n      }\n\n      if (scheduledCallback !== null) {\n        isFlushing = true;\n\n        try {\n          var hasMoreWork = scheduledCallback(false, currentTime);\n\n          if (!hasMoreWork) {\n            scheduledCallback = null;\n          }\n        } finally {\n          isFlushing = false;\n        }\n      }\n    }\n\n    function unstable_flushAllWithoutAsserting() {\n      // Returns false if no work was flushed.\n      if (isFlushing) {\n        throw new Error('Already flushing work.');\n      }\n\n      if (scheduledCallback !== null) {\n        var cb = scheduledCallback;\n        isFlushing = true;\n\n        try {\n          var hasMoreWork = true;\n\n          do {\n            hasMoreWork = cb(true, currentTime);\n          } while (hasMoreWork);\n\n          if (!hasMoreWork) {\n            scheduledCallback = null;\n          }\n\n          return true;\n        } finally {\n          isFlushing = false;\n        }\n      } else {\n        return false;\n      }\n    }\n\n    function unstable_clearYields() {\n      if (yieldedValues === null) {\n        return [];\n      }\n\n      var values = yieldedValues;\n      yieldedValues = null;\n      return values;\n    }\n\n    function unstable_flushAll() {\n      if (yieldedValues !== null) {\n        throw new Error('Log is not empty. Assert on the log of yielded values before ' + 'flushing additional work.');\n      }\n\n      unstable_flushAllWithoutAsserting();\n\n      if (yieldedValues !== null) {\n        throw new Error('While flushing work, something yielded a value. Use an ' + 'assertion helper to assert on the log of yielded values, e.g. ' + 'expect(Scheduler).toFlushAndYield([...])');\n      }\n    }\n\n    function unstable_yieldValue(value) {\n      if (yieldedValues === null) {\n        yieldedValues = [value];\n      } else {\n        yieldedValues.push(value);\n      }\n    }\n\n    function unstable_advanceTime(ms) {\n      currentTime += ms;\n\n      if (!isFlushing) {\n        if (scheduledTimeout !== null && timeoutTime <= currentTime) {\n          scheduledTimeout(currentTime);\n          timeoutTime = -1;\n          scheduledTimeout = null;\n        }\n\n        unstable_flushExpired();\n      }\n    }\n\n    function requestPaint() {\n      needsPaint = true;\n    }\n    /* eslint-disable no-var */\n    // TODO: Use symbols?\n\n\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5; // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY = maxSigned31BitInt; // Tasks are stored as a circular, doubly linked list.\n\n    var firstTask = null;\n    var firstDelayedTask = null; // Pausing the scheduler is useful for debugging.\n\n    var isSchedulerPaused = false;\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false;\n\n    function scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\n      return callback(didTimeout);\n    }\n\n    function flushTask(task, currentTime) {\n      // Remove the task from the list before calling the callback. That way the\n      // list is in a consistent state even if the callback throws.\n      var next = task.next;\n\n      if (next === task) {\n        // This is the only scheduled task. Clear the list.\n        firstTask = null;\n      } else {\n        // Remove the task from its position in the list.\n        if (task === firstTask) {\n          firstTask = next;\n        }\n\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      task.next = task.previous = null; // Now it's safe to execute the task.\n\n      var callback = task.callback;\n      var previousPriorityLevel = currentPriorityLevel;\n      var previousTask = currentTask;\n      currentPriorityLevel = task.priorityLevel;\n      currentTask = task;\n      var continuationCallback;\n\n      try {\n        var didUserCallbackTimeout = task.expirationTime <= currentTime; // Add an extra function to the callstack. Profiling tools can use this\n        // to infer the priority of work that appears higher in the stack.\n\n        switch (currentPriorityLevel) {\n          case ImmediatePriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\n            break;\n\n          case UserBlockingPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\n            break;\n\n          case NormalPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\n            break;\n\n          case LowPriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\n            break;\n\n          case IdlePriority:\n            continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\n            break;\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n        currentTask = previousTask;\n      } // A callback may return a continuation. The continuation should be scheduled\n      // with the same priority and expiration as the just-finished callback.\n\n\n      if (typeof continuationCallback === 'function') {\n        var expirationTime = task.expirationTime;\n        var continuationTask = task;\n        continuationTask.callback = continuationCallback; // Insert the new callback into the list, sorted by its timeout. This is\n        // almost the same as the code in `scheduleCallback`, except the callback\n        // is inserted into the list *before* callbacks of equal timeout instead\n        // of after.\n\n        if (firstTask === null) {\n          // This is the first callback in the list.\n          firstTask = continuationTask.next = continuationTask.previous = continuationTask;\n        } else {\n          var nextAfterContinuation = null;\n          var t = firstTask;\n\n          do {\n            if (expirationTime <= t.expirationTime) {\n              // This task times out at or after the continuation. We will insert\n              // the continuation *before* this task.\n              nextAfterContinuation = t;\n              break;\n            }\n\n            t = t.next;\n          } while (t !== firstTask);\n\n          if (nextAfterContinuation === null) {\n            // No equal or lower priority task was found, which means the new task\n            // is the lowest priority task in the list.\n            nextAfterContinuation = firstTask;\n          } else if (nextAfterContinuation === firstTask) {\n            // The new task is the highest priority task in the list.\n            firstTask = continuationTask;\n          }\n\n          var _previous = nextAfterContinuation.previous;\n          _previous.next = nextAfterContinuation.previous = continuationTask;\n          continuationTask.next = nextAfterContinuation;\n          continuationTask.previous = _previous;\n        }\n      }\n    }\n\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\n        do {\n          var task = firstDelayedTask;\n          var next = task.next;\n\n          if (task === next) {\n            firstDelayedTask = null;\n          } else {\n            firstDelayedTask = next;\n            var previous = task.previous;\n            previous.next = next;\n            next.previous = previous;\n          }\n\n          task.next = task.previous = null;\n          insertScheduledTask(task, task.expirationTime);\n        } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\n      }\n    }\n\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n\n      if (!isHostCallbackScheduled) {\n        if (firstTask !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else if (firstDelayedTask !== null) {\n          requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n        }\n      }\n    }\n\n    function flushWork(hasTimeRemaining, initialTime) {\n      // Exit right away if we're currently paused\n      if (enableSchedulerDebugging && isSchedulerPaused) {\n        return;\n      } // We'll need a host callback the next time work is scheduled.\n\n\n      isHostCallbackScheduled = false;\n\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      isPerformingWork = true;\n\n      try {\n        if (!hasTimeRemaining) {\n          // Flush all the expired callbacks without yielding.\n          // TODO: Split flushWork into two separate functions instead of using\n          // a boolean argument?\n          while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\n            flushTask(firstTask, currentTime);\n            currentTime = getCurrentTime();\n            advanceTimers(currentTime);\n          }\n        } else {\n          // Keep flushing callbacks until we run out of time in the frame.\n          if (firstTask !== null) {\n            do {\n              flushTask(firstTask, currentTime);\n              currentTime = getCurrentTime();\n              advanceTimers(currentTime);\n            } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\n          }\n        } // Return whether there's additional work\n\n\n        if (firstTask !== null) {\n          return true;\n        } else {\n          if (firstDelayedTask !== null) {\n            requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n          }\n\n          return false;\n        }\n      } finally {\n        isPerformingWork = false;\n      }\n    }\n\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n\n        default:\n          priorityLevel = NormalPriority;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n\n    function timeoutForPriorityLevel(priorityLevel) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          return IMMEDIATE_PRIORITY_TIMEOUT;\n\n        case UserBlockingPriority:\n          return USER_BLOCKING_PRIORITY;\n\n        case IdlePriority:\n          return IDLE_PRIORITY;\n\n        case LowPriority:\n          return LOW_PRIORITY_TIMEOUT;\n\n        case NormalPriority:\n        default:\n          return NORMAL_PRIORITY_TIMEOUT;\n      }\n    }\n\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = getCurrentTime();\n      var startTime;\n      var timeout;\n\n      if (typeof options === 'object' && options !== null) {\n        var delay = options.delay;\n\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n\n        timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n      } else {\n        timeout = timeoutForPriorityLevel(priorityLevel);\n        startTime = currentTime;\n      }\n\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        next: null,\n        previous: null\n      };\n\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        insertDelayedTask(newTask, startTime);\n\n        if (firstTask === null && firstDelayedTask === newTask) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        insertScheduledTask(newTask, expirationTime); // Schedule a host callback, if needed. If we're already performing work,\n        // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n\n      return newTask;\n    }\n\n    function insertScheduledTask(newTask, expirationTime) {\n      // Insert the new task into the list, ordered first by its timeout, then by\n      // insertion. So the new task is inserted after any other task the\n      // same timeout\n      if (firstTask === null) {\n        // This is the first task in the list.\n        firstTask = newTask.next = newTask.previous = newTask;\n      } else {\n        var next = null;\n        var task = firstTask;\n\n        do {\n          if (expirationTime < task.expirationTime) {\n            // The new task times out before this one.\n            next = task;\n            break;\n          }\n\n          task = task.next;\n        } while (task !== firstTask);\n\n        if (next === null) {\n          // No task with a later timeout was found, which means the new task has\n          // the latest timeout in the list.\n          next = firstTask;\n        } else if (next === firstTask) {\n          // The new task has the earliest expiration in the entire list.\n          firstTask = newTask;\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newTask;\n        newTask.next = next;\n        newTask.previous = previous;\n      }\n    }\n\n    function insertDelayedTask(newTask, startTime) {\n      // Insert the new task into the list, ordered by its start time.\n      if (firstDelayedTask === null) {\n        // This is the first task in the list.\n        firstDelayedTask = newTask.next = newTask.previous = newTask;\n      } else {\n        var next = null;\n        var task = firstDelayedTask;\n\n        do {\n          if (startTime < task.startTime) {\n            // The new task times out before this one.\n            next = task;\n            break;\n          }\n\n          task = task.next;\n        } while (task !== firstDelayedTask);\n\n        if (next === null) {\n          // No task with a later timeout was found, which means the new task has\n          // the latest timeout in the list.\n          next = firstDelayedTask;\n        } else if (next === firstDelayedTask) {\n          // The new task has the earliest expiration in the entire list.\n          firstDelayedTask = newTask;\n        }\n\n        var previous = next.previous;\n        previous.next = next.previous = newTask;\n        newTask.next = next;\n        newTask.previous = previous;\n      }\n    }\n\n    function unstable_pauseExecution() {\n      isSchedulerPaused = true;\n    }\n\n    function unstable_continueExecution() {\n      isSchedulerPaused = false;\n\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n\n    function unstable_getFirstCallbackNode() {\n      return firstTask;\n    }\n\n    function unstable_cancelCallback(task) {\n      var next = task.next;\n\n      if (next === null) {\n        // Already cancelled.\n        return;\n      }\n\n      if (task === next) {\n        if (task === firstTask) {\n          firstTask = null;\n        } else if (task === firstDelayedTask) {\n          firstDelayedTask = null;\n        }\n      } else {\n        if (task === firstTask) {\n          firstTask = next;\n        } else if (task === firstDelayedTask) {\n          firstDelayedTask = next;\n        }\n\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n\n      task.next = task.previous = null;\n    }\n\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n\n    function unstable_shouldYield() {\n      var currentTime = getCurrentTime();\n      advanceTimers(currentTime);\n      return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n    }\n\n    var unstable_requestPaint = requestPaint;\n    exports.unstable_flushAllWithoutAsserting = unstable_flushAllWithoutAsserting;\n    exports.unstable_flushNumberOfYields = unstable_flushNumberOfYields;\n    exports.unstable_flushExpired = unstable_flushExpired;\n    exports.unstable_clearYields = unstable_clearYields;\n    exports.unstable_flushUntilNextPaint = unstable_flushUntilNextPaint;\n    exports.unstable_flushAll = unstable_flushAll;\n    exports.unstable_yieldValue = unstable_yieldValue;\n    exports.unstable_advanceTime = unstable_advanceTime;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_next = unstable_next;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_shouldYield = unstable_shouldYield;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n    exports.unstable_now = getCurrentTime;\n    exports.unstable_forceFrameRate = forceFrameRate;\n  })();\n}","map":{"version":3,"sources":["C:/Koodaus/GIT/webcomptest/content-scroller/node_modules/react-test-renderer/node_modules/scheduler/cjs/scheduler-unstable_mock.development.js"],"names":["process","env","NODE_ENV","Object","defineProperty","exports","value","enableSchedulerDebugging","currentTime","scheduledCallback","scheduledTimeout","timeoutTime","yieldedValues","expectedNumberOfYields","didStop","isFlushing","needsPaint","shouldYieldForPaint","requestHostCallback","callback","requestHostTimeout","ms","cancelHostTimeout","shouldYieldToHost","length","getCurrentTime","forceFrameRate","unstable_flushNumberOfYields","count","Error","cb","hasMoreWork","unstable_flushUntilNextPaint","unstable_flushExpired","unstable_flushAllWithoutAsserting","unstable_clearYields","values","unstable_flushAll","unstable_yieldValue","push","unstable_advanceTime","requestPaint","ImmediatePriority","UserBlockingPriority","NormalPriority","LowPriority","IdlePriority","maxSigned31BitInt","IMMEDIATE_PRIORITY_TIMEOUT","USER_BLOCKING_PRIORITY","NORMAL_PRIORITY_TIMEOUT","LOW_PRIORITY_TIMEOUT","IDLE_PRIORITY","firstTask","firstDelayedTask","isSchedulerPaused","currentTask","currentPriorityLevel","isPerformingWork","isHostCallbackScheduled","isHostTimeoutScheduled","scheduler_flushTaskAtPriority_Immediate","didTimeout","scheduler_flushTaskAtPriority_UserBlocking","scheduler_flushTaskAtPriority_Normal","scheduler_flushTaskAtPriority_Low","scheduler_flushTaskAtPriority_Idle","flushTask","task","next","previous","previousPriorityLevel","previousTask","priorityLevel","continuationCallback","didUserCallbackTimeout","expirationTime","error","continuationTask","nextAfterContinuation","t","_previous","advanceTimers","startTime","insertScheduledTask","handleTimeout","flushWork","hasTimeRemaining","initialTime","unstable_runWithPriority","eventHandler","unstable_next","unstable_wrapCallback","parentPriorityLevel","apply","arguments","timeoutForPriorityLevel","unstable_scheduleCallback","options","timeout","delay","newTask","insertDelayedTask","unstable_pauseExecution","unstable_continueExecution","unstable_getFirstCallbackNode","unstable_cancelCallback","unstable_getCurrentPriorityLevel","unstable_shouldYield","unstable_requestPaint","unstable_ImmediatePriority","unstable_UserBlockingPriority","unstable_NormalPriority","unstable_IdlePriority","unstable_LowPriority","unstable_now","unstable_forceFrameRate"],"mappings":"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","sourcesContent":["/** @license React v0.15.0\n * scheduler-unstable_mock.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar enableSchedulerDebugging = false;\n\nvar currentTime = 0;\nvar scheduledCallback = null;\nvar scheduledTimeout = null;\nvar timeoutTime = -1;\nvar yieldedValues = null;\nvar expectedNumberOfYields = -1;\nvar didStop = false;\nvar isFlushing = false;\nvar needsPaint = false;\nvar shouldYieldForPaint = false;\n\nfunction requestHostCallback(callback) {\n  scheduledCallback = callback;\n}\n\n\n\nfunction requestHostTimeout(callback, ms) {\n  scheduledTimeout = callback;\n  timeoutTime = currentTime + ms;\n}\n\nfunction cancelHostTimeout() {\n  scheduledTimeout = null;\n  timeoutTime = -1;\n}\n\nfunction shouldYieldToHost() {\n  if (expectedNumberOfYields !== -1 && yieldedValues !== null && yieldedValues.length >= expectedNumberOfYields || shouldYieldForPaint && needsPaint) {\n    // We yielded at least as many values as expected. Stop flushing.\n    didStop = true;\n    return true;\n  }\n  return false;\n}\n\nfunction getCurrentTime() {\n  return currentTime;\n}\n\nfunction forceFrameRate() {\n  // No-op\n}\n\n\n\n// Should only be used via an assertion helper that inspects the yielded values.\nfunction unstable_flushNumberOfYields(count) {\n  if (isFlushing) {\n    throw new Error('Already flushing work.');\n  }\n  if (scheduledCallback !== null) {\n    var cb = scheduledCallback;\n    expectedNumberOfYields = count;\n    isFlushing = true;\n    try {\n      var hasMoreWork = true;\n      do {\n        hasMoreWork = cb(true, currentTime);\n      } while (hasMoreWork && !didStop);\n      if (!hasMoreWork) {\n        scheduledCallback = null;\n      }\n    } finally {\n      expectedNumberOfYields = -1;\n      didStop = false;\n      isFlushing = false;\n    }\n  }\n}\n\nfunction unstable_flushUntilNextPaint() {\n  if (isFlushing) {\n    throw new Error('Already flushing work.');\n  }\n  if (scheduledCallback !== null) {\n    var cb = scheduledCallback;\n    shouldYieldForPaint = true;\n    needsPaint = false;\n    isFlushing = true;\n    try {\n      var hasMoreWork = true;\n      do {\n        hasMoreWork = cb(true, currentTime);\n      } while (hasMoreWork && !didStop);\n      if (!hasMoreWork) {\n        scheduledCallback = null;\n      }\n    } finally {\n      shouldYieldForPaint = false;\n      didStop = false;\n      isFlushing = false;\n    }\n  }\n}\n\nfunction unstable_flushExpired() {\n  if (isFlushing) {\n    throw new Error('Already flushing work.');\n  }\n  if (scheduledCallback !== null) {\n    isFlushing = true;\n    try {\n      var hasMoreWork = scheduledCallback(false, currentTime);\n      if (!hasMoreWork) {\n        scheduledCallback = null;\n      }\n    } finally {\n      isFlushing = false;\n    }\n  }\n}\n\nfunction unstable_flushAllWithoutAsserting() {\n  // Returns false if no work was flushed.\n  if (isFlushing) {\n    throw new Error('Already flushing work.');\n  }\n  if (scheduledCallback !== null) {\n    var cb = scheduledCallback;\n    isFlushing = true;\n    try {\n      var hasMoreWork = true;\n      do {\n        hasMoreWork = cb(true, currentTime);\n      } while (hasMoreWork);\n      if (!hasMoreWork) {\n        scheduledCallback = null;\n      }\n      return true;\n    } finally {\n      isFlushing = false;\n    }\n  } else {\n    return false;\n  }\n}\n\nfunction unstable_clearYields() {\n  if (yieldedValues === null) {\n    return [];\n  }\n  var values = yieldedValues;\n  yieldedValues = null;\n  return values;\n}\n\nfunction unstable_flushAll() {\n  if (yieldedValues !== null) {\n    throw new Error('Log is not empty. Assert on the log of yielded values before ' + 'flushing additional work.');\n  }\n  unstable_flushAllWithoutAsserting();\n  if (yieldedValues !== null) {\n    throw new Error('While flushing work, something yielded a value. Use an ' + 'assertion helper to assert on the log of yielded values, e.g. ' + 'expect(Scheduler).toFlushAndYield([...])');\n  }\n}\n\nfunction unstable_yieldValue(value) {\n  if (yieldedValues === null) {\n    yieldedValues = [value];\n  } else {\n    yieldedValues.push(value);\n  }\n}\n\nfunction unstable_advanceTime(ms) {\n  currentTime += ms;\n  if (!isFlushing) {\n    if (scheduledTimeout !== null && timeoutTime <= currentTime) {\n      scheduledTimeout(currentTime);\n      timeoutTime = -1;\n      scheduledTimeout = null;\n    }\n    unstable_flushExpired();\n  }\n}\n\nfunction requestPaint() {\n  needsPaint = true;\n}\n\n/* eslint-disable no-var */\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\n// Times out immediately\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1;\n// Eventually times out\nvar USER_BLOCKING_PRIORITY = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000;\n// Never times out\nvar IDLE_PRIORITY = maxSigned31BitInt;\n\n// Tasks are stored as a circular, doubly linked list.\nvar firstTask = null;\nvar firstDelayedTask = null;\n\n// Pausing the scheduler is useful for debugging.\nvar isSchedulerPaused = false;\n\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority;\n\n// This is set while performing work, to prevent re-entrancy.\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false;\n\nfunction scheduler_flushTaskAtPriority_Immediate(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_UserBlocking(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Normal(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Low(callback, didTimeout) {\n  return callback(didTimeout);\n}\nfunction scheduler_flushTaskAtPriority_Idle(callback, didTimeout) {\n  return callback(didTimeout);\n}\n\nfunction flushTask(task, currentTime) {\n  // Remove the task from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = task.next;\n  if (next === task) {\n    // This is the only scheduled task. Clear the list.\n    firstTask = null;\n  } else {\n    // Remove the task from its position in the list.\n    if (task === firstTask) {\n      firstTask = next;\n    }\n    var previous = task.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n  task.next = task.previous = null;\n\n  // Now it's safe to execute the task.\n  var callback = task.callback;\n  var previousPriorityLevel = currentPriorityLevel;\n  var previousTask = currentTask;\n  currentPriorityLevel = task.priorityLevel;\n  currentTask = task;\n  var continuationCallback;\n  try {\n    var didUserCallbackTimeout = task.expirationTime <= currentTime;\n    // Add an extra function to the callstack. Profiling tools can use this\n    // to infer the priority of work that appears higher in the stack.\n    switch (currentPriorityLevel) {\n      case ImmediatePriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Immediate(callback, didUserCallbackTimeout);\n        break;\n      case UserBlockingPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_UserBlocking(callback, didUserCallbackTimeout);\n        break;\n      case NormalPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Normal(callback, didUserCallbackTimeout);\n        break;\n      case LowPriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Low(callback, didUserCallbackTimeout);\n        break;\n      case IdlePriority:\n        continuationCallback = scheduler_flushTaskAtPriority_Idle(callback, didUserCallbackTimeout);\n        break;\n    }\n  } catch (error) {\n    throw error;\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n    currentTask = previousTask;\n  }\n\n  // A callback may return a continuation. The continuation should be scheduled\n  // with the same priority and expiration as the just-finished callback.\n  if (typeof continuationCallback === 'function') {\n    var expirationTime = task.expirationTime;\n    var continuationTask = task;\n    continuationTask.callback = continuationCallback;\n\n    // Insert the new callback into the list, sorted by its timeout. This is\n    // almost the same as the code in `scheduleCallback`, except the callback\n    // is inserted into the list *before* callbacks of equal timeout instead\n    // of after.\n    if (firstTask === null) {\n      // This is the first callback in the list.\n      firstTask = continuationTask.next = continuationTask.previous = continuationTask;\n    } else {\n      var nextAfterContinuation = null;\n      var t = firstTask;\n      do {\n        if (expirationTime <= t.expirationTime) {\n          // This task times out at or after the continuation. We will insert\n          // the continuation *before* this task.\n          nextAfterContinuation = t;\n          break;\n        }\n        t = t.next;\n      } while (t !== firstTask);\n      if (nextAfterContinuation === null) {\n        // No equal or lower priority task was found, which means the new task\n        // is the lowest priority task in the list.\n        nextAfterContinuation = firstTask;\n      } else if (nextAfterContinuation === firstTask) {\n        // The new task is the highest priority task in the list.\n        firstTask = continuationTask;\n      }\n\n      var _previous = nextAfterContinuation.previous;\n      _previous.next = nextAfterContinuation.previous = continuationTask;\n      continuationTask.next = nextAfterContinuation;\n      continuationTask.previous = _previous;\n    }\n  }\n}\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  if (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime) {\n    do {\n      var task = firstDelayedTask;\n      var next = task.next;\n      if (task === next) {\n        firstDelayedTask = null;\n      } else {\n        firstDelayedTask = next;\n        var previous = task.previous;\n        previous.next = next;\n        next.previous = previous;\n      }\n      task.next = task.previous = null;\n      insertScheduledTask(task, task.expirationTime);\n    } while (firstDelayedTask !== null && firstDelayedTask.startTime <= currentTime);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (firstTask !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else if (firstDelayedTask !== null) {\n      requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n  // Exit right away if we're currently paused\n  if (enableSchedulerDebugging && isSchedulerPaused) {\n    return;\n  }\n\n  // We'll need a host callback the next time work is scheduled.\n  isHostCallbackScheduled = false;\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n\n  isPerformingWork = true;\n  try {\n    if (!hasTimeRemaining) {\n      // Flush all the expired callbacks without yielding.\n      // TODO: Split flushWork into two separate functions instead of using\n      // a boolean argument?\n      while (firstTask !== null && firstTask.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused)) {\n        flushTask(firstTask, currentTime);\n        currentTime = getCurrentTime();\n        advanceTimers(currentTime);\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstTask !== null) {\n        do {\n          flushTask(firstTask, currentTime);\n          currentTime = getCurrentTime();\n          advanceTimers(currentTime);\n        } while (firstTask !== null && !shouldYieldToHost() && !(enableSchedulerDebugging && isSchedulerPaused));\n      }\n    }\n    // Return whether there's additional work\n    if (firstTask !== null) {\n      return true;\n    } else {\n      if (firstDelayedTask !== null) {\n        requestHostTimeout(handleTimeout, firstDelayedTask.startTime - currentTime);\n      }\n      return false;\n    }\n  } finally {\n    isPerformingWork = false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction timeoutForPriorityLevel(priorityLevel) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      return IMMEDIATE_PRIORITY_TIMEOUT;\n    case UserBlockingPriority:\n      return USER_BLOCKING_PRIORITY;\n    case IdlePriority:\n      return IDLE_PRIORITY;\n    case LowPriority:\n      return LOW_PRIORITY_TIMEOUT;\n    case NormalPriority:\n    default:\n      return NORMAL_PRIORITY_TIMEOUT;\n  }\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = getCurrentTime();\n\n  var startTime;\n  var timeout;\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n    timeout = typeof options.timeout === 'number' ? options.timeout : timeoutForPriorityLevel(priorityLevel);\n  } else {\n    timeout = timeoutForPriorityLevel(priorityLevel);\n    startTime = currentTime;\n  }\n\n  var expirationTime = startTime + timeout;\n\n  var newTask = {\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    next: null,\n    previous: null\n  };\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    insertDelayedTask(newTask, startTime);\n    if (firstTask === null && firstDelayedTask === newTask) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      }\n      // Schedule a timeout.\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    insertScheduledTask(newTask, expirationTime);\n    // Schedule a host callback, if needed. If we're already performing work,\n    // wait until the next time we yield.\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction insertScheduledTask(newTask, expirationTime) {\n  // Insert the new task into the list, ordered first by its timeout, then by\n  // insertion. So the new task is inserted after any other task the\n  // same timeout\n  if (firstTask === null) {\n    // This is the first task in the list.\n    firstTask = newTask.next = newTask.previous = newTask;\n  } else {\n    var next = null;\n    var task = firstTask;\n    do {\n      if (expirationTime < task.expirationTime) {\n        // The new task times out before this one.\n        next = task;\n        break;\n      }\n      task = task.next;\n    } while (task !== firstTask);\n\n    if (next === null) {\n      // No task with a later timeout was found, which means the new task has\n      // the latest timeout in the list.\n      next = firstTask;\n    } else if (next === firstTask) {\n      // The new task has the earliest expiration in the entire list.\n      firstTask = newTask;\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newTask;\n    newTask.next = next;\n    newTask.previous = previous;\n  }\n}\n\nfunction insertDelayedTask(newTask, startTime) {\n  // Insert the new task into the list, ordered by its start time.\n  if (firstDelayedTask === null) {\n    // This is the first task in the list.\n    firstDelayedTask = newTask.next = newTask.previous = newTask;\n  } else {\n    var next = null;\n    var task = firstDelayedTask;\n    do {\n      if (startTime < task.startTime) {\n        // The new task times out before this one.\n        next = task;\n        break;\n      }\n      task = task.next;\n    } while (task !== firstDelayedTask);\n\n    if (next === null) {\n      // No task with a later timeout was found, which means the new task has\n      // the latest timeout in the list.\n      next = firstDelayedTask;\n    } else if (next === firstDelayedTask) {\n      // The new task has the earliest expiration in the entire list.\n      firstDelayedTask = newTask;\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newTask;\n    newTask.next = next;\n    newTask.previous = previous;\n  }\n}\n\nfunction unstable_pauseExecution() {\n  isSchedulerPaused = true;\n}\n\nfunction unstable_continueExecution() {\n  isSchedulerPaused = false;\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return firstTask;\n}\n\nfunction unstable_cancelCallback(task) {\n  var next = task.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (task === next) {\n    if (task === firstTask) {\n      firstTask = null;\n    } else if (task === firstDelayedTask) {\n      firstDelayedTask = null;\n    }\n  } else {\n    if (task === firstTask) {\n      firstTask = next;\n    } else if (task === firstDelayedTask) {\n      firstDelayedTask = next;\n    }\n    var previous = task.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  task.next = task.previous = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nfunction unstable_shouldYield() {\n  var currentTime = getCurrentTime();\n  advanceTimers(currentTime);\n  return currentTask !== null && firstTask !== null && firstTask.startTime <= currentTime && firstTask.expirationTime < currentTask.expirationTime || shouldYieldToHost();\n}\n\nvar unstable_requestPaint = requestPaint;\n\nexports.unstable_flushAllWithoutAsserting = unstable_flushAllWithoutAsserting;\nexports.unstable_flushNumberOfYields = unstable_flushNumberOfYields;\nexports.unstable_flushExpired = unstable_flushExpired;\nexports.unstable_clearYields = unstable_clearYields;\nexports.unstable_flushUntilNextPaint = unstable_flushUntilNextPaint;\nexports.unstable_flushAll = unstable_flushAll;\nexports.unstable_yieldValue = unstable_yieldValue;\nexports.unstable_advanceTime = unstable_advanceTime;\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_next = unstable_next;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_wrapCallback = unstable_wrapCallback;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_shouldYield = unstable_shouldYield;\nexports.unstable_requestPaint = unstable_requestPaint;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\nexports.unstable_now = getCurrentTime;\nexports.unstable_forceFrameRate = forceFrameRate;\n  })();\n}\n"]},"metadata":{},"sourceType":"script"}